<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>function对象</title>
   <script charset="utf-8">
     /* 
      Fun餐厅： 函数（方法）对象
      1. 创建
        1. var fun = new Function(形式参数列表，方法体); // 忘掉把
        2. function 方法名(形式参数列表）{
              方法体
              }
        3. var 方法名 = function(形式参数列表){
          
        )

      2, 方法：
      3. 属性
      length: 代表形参（参数)的个数
        
      4. 特点
         1. 方法定义时形参类型不用写, 返回值类型也可以不写，即 参数不用写var a , var b ;  直接function (a, b)
         2. 方法是一个对象, 如果出现重名，后面的会覆盖前面的,和Java不同，java会报错
         3. 在JS中，方法的调用值与方法的名称有关，和参数列表无关！（即，定义方法有2个参数，调用方法时，传多少个参数，甚至不传也可以）
         4. 在方法用声明中有一个隐藏的内置对象（数组），arguments,封装了所有的参数列表

      5. 调用： 
        方法名称（实际参数列表）：
        */

    // 1. 创建方式1
    var fun1 = new Function("a", "b", "alert(a)"); // 非常少用，不方便，忘记把
    // 调用方法
    //fun1(3,4);
    
    // 2. 创建方法2
    function fun2(a, b){
      alert(a+b);
    }
    //fun2(3,5);

    // 3. 
    var fun3 = function(a, b){
      alert(a + b);
    }
    // fun3(3, 4)

    // 特点2： 方法是一个对象，如果出现重名，后面的会覆盖前面的 ,和Java不同，java会报错
    fun2 = function(a, b){
      alert(a * b );
    }
    function fun2(a, b){
       alert(a -b);
    }
    // fun2(3, 4);
    

    // 特点3： 就算
     //3. 在JS中，方法的调用值与方法的名称有关，和参数列表无关！（即，定义方法有2个参数，调用方法时，传多少个参数，甚至不传也可以）
    function fun2(a, b){ // 2个参数
      alert(a); 
      alert(b);
    }

    // 方法调用
    // fun2(1);
    //fun2(); // 定义方法时
    //fun2(1, 2, 3); // 超过定义的参数个数也可以
    
    // 特点4 
     // 4. 在方法用声明中有一个隐藏的内置对象（数组），arguments,封装了所有的参数列表
    /** 
      求任意个数的和
      */
    function add (){ //直接不定义参数，因为有一个隐藏的内置对象（数组），arguments,封装了所有的参数列表
      alert(arguments[0]);
      alert(arguments[1]);
      var sum  = 0;
      for (var i = 0 ; i < arguments.length; i++){
        sum += arguments[i];
      }
      return sum;

    }
    var sum = add(1, 2, 3);
    alert(sum);
  

   </script> 
  </head>
  <body>
    
  </body>
</html>
